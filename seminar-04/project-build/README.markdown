# Системы сборки

### Agenda
  * Стадии сборки проекта
  * Инструментарий для сборки
    * сборочные bash-скрипты
    * make
    * cmake
    
# Cтадии сборки проекта

Насколько верно со снобисткой точки зрения фразочки в духе: "программа откомпилировалась без ошибок" или "скомпилируй программу, посмотрим на результат работы"?  
Подсказка: ничего хорошо, они приводят только к путаницы начинающих программистов и говорят об отсутствии компетенции у автора подобных фразочек.
<details><summary>А что тогда говорить?</summary>
<p>
Исходник на C++ — это всего лишь plain text, это значит, что сам по себе он бесполезен, на него можно только глазками посмотреть. 
Поэтому каждый исходный файл требуется скомпилировать в исполняемый файл, динамическую или статическую библиотеки (пытливый читатель
спросит в чем разница между динамической и статической библиотекой — гугл в помощь млм дождитесь АКОСа).  
  
Итак, сами стадии сборки проекта:
  1. Препроцессинг
  2. Компиляция
  3. Ассемблирование
  4. Компоновка (линковка)

**Препроцессинг**  
На данной стадии происходит происходит работа с препроцессорными директивами. Например, препроцессор добавляет хэдеры в код (#include), убирает комментирования, заменяет макросы (#define) их значениями, выбирает нужные куски кода в соответствии с условиями #if, #ifdef и #ifndef.  
```bash
g++ -E -o main.i main.cpp
```

**Компиляция**  
На данной стадии происходит преобразование полученном на прошлом шаге кода без директив в ассемблерный код.
_Ассемблерный код_ — это доступное для понимания человеком представление машинного кода.
```bash
g++ -S -o main.s main.cpp
```

**Ассемблирование**  
На данной стадии необходимо перевести ассемблерный код в машинный с помощью ассемблера.
Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном файле. 
_Объектный файл_ — это созданный ассемблером промежуточный файл, хранящий кусок машинного кода. Этот кусок машинного кода, который еще не был связан вместе с другими кусками машинного кода в конечную выполняемую программу, называется объектным кодом.
```bash
g++ -c -o main.o main.cpp
```
или
```bash
as main.s -o main.o
```
**Компоновка**  
На данной стадии происходит связывание всех объектных файлов и статических библиотек в единый исполняемый файл, который мы и сможем запустить в дальнейшем.
```bash
g++ main.o file1.o ... fileN.o lib1.o ... libN.o -o main
```

**\*Загрузка**  
Формально к сборке проекта никакого отношения не имеет, но надо понимать, что для непосредственно
запуска нашего приложения, программу надо загрузить в память. 

</p>
</details>

### Обсудив стадии сборки проекта, заодно мы сразу посмотрели на сборочные bash-скрипты, какие недостатки такого подхода вы сразу можете назвать?

### Make
make — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта. Сам скрипт состоит из набора правил, которые в свою очередь описываются:

1) целями (то, что данное правило делает);
2) реквизитами (то, что необходимо для выполнения правила и получения целей);
3) командами (выполняющими данные преобразования).

В общем виде синтаксис makefile можно представить так:  
```bash
# Индентация осуществляется исключительно при помощи символов табуляции,
# каждой команде должен предшествовать отступ
<цели>: <реквизиты>
	<команда 1>
	...
	<команда N>
```
Несложно заметить что процессы трансляции и компиляции очень красиво ложатся на эту схему:
```bash
{исходные файлы} ---> [трансляция] ---> {объектные файлы}
```
```bash
{объектные файлы} ---> [линковка] ---> {исполнимые файлы}
```

**Простейший пример использования make**
```c
/*
 * main.c
 */
#include <stdio.h>
int main() {
	printf("Hello World!\n");
	return 0;
}
```
```bash
hello: main.c
	gcc -o hello main.c
```
Теперь для сборки достаточно вызвать нужное правило:
```bash
$ make hello
```
Заодно посмотрим на многофайловый пример.  
...  
А что если наша программа состоит из десятка-другого исходных файлов. Мы вносим изменения в один из них, и хотим ее пересобрать. 
Использование подхода описанного в предыдущем примере приведет к тому, что все без исключения исходные файлы будут снова скомпилированы, что негативно скажется на времени перекомпиляции. Решение — разделить компиляцию на два этапа: этап трансляции в объектные файлы и этап линковки.  
```bash
main.o: main.c
        gcc -c -o main.o main.c
hello.o: hello.c
        gcc -c -o hello.o hello.c
hello: main.o hello.o
        gcc -o hello main.o hello.o
```
**Фиктивные цели**  
На самом деле, в качестве make целей могут выступать не только реальные файлы. Проделывать такие фокусы нам позволяют так называемые фиктивные (phony) цели. Вот краткий список стандартных целей:
  * ```all``` — является стандартной целью по умолчанию, при вызове make ее можно явно не указывать
  * ```clean``` — очистить каталог от всех файлов полученных в результате компиляции
  * ```install``` — произвести инсталляцию
  * ```uninstall``` — и деинсталляцию соответственно
Пример Makefile с целями all, clean, install и uninstall:
```bash
.PHONY: all clean install uninstall
	
all: hello
	
clean:
			rm -rf hello *.o
main.o: main.c
			gcc -c -o main.o main.c
hello.o: hello.c
			gcc -c -o hello.o hello.c
hello: main.o hello.o
			gcc -o hello main.o hello.o
install:
			install ./hello /usr/local/bin
uninstall:
			rm -rf /usr/local/bin/hello
```
Также в Makefile можно использовать переменные по ```bash'овому``` подходу:
```bash
<VAR_NAME> = <value string>
```
чтобы получить значение по переменной воспользуемся следующим синтаксисом:
```bash
SRC = main.c hello.c
gcc -o hello $(SRC)
```
  
```bash
TARGET = hello
PREFIX = /usr/local/bin

.PHONY: all clean install uninstall

all: $(TARGET)
	
clean:
			rm -rf $(TARGET) *.o
main.o: main.c
			gcc -c -o main.o main.c
hello.o: hello.c
			gcc -c -o hello.o hello.c
$(TARGET): main.o hello.o
			gcc -o $(TARGET) main.o hello.o
install:
			install $(TARGET) $(PREFIX)
uninstall:
			rm -rf $(PREFIX)/$(TARGET)
```
***В конце добавлю, что make - это не кроссплатформенная утилита!***

### CMake
CMake — это открытый и кросс-платформенный набор утилит, предназначенных для автоматизации тестирования, компиляции и создания пакетов проектов на C/C++.

**Команды**  
Команды в CMake подобны функциям во многих языках программирования. Чтобы вызвать команду, необходимо написать её имя, а затем передать ей обрамлённые в круглые скобки аргументы, отделённые символами пробелов. В приведённом примере команде message передаются шесть аргументов для вывода в консоль:
```shell
# Напечатает в консоль "CMake is the most powerful buildsystem!"
message("CMake " "is " "the " "most " "powerful " "buildsystem!")
```

**Аргументы**  
Аргументы, обрамлённые в двойные кавычки, позволяют внутри себя совершать экранирование и подстановку переменных. Необрамлённые аргументы не позволяют производить подобных вещей и не могут включать в себя символы ```()#"\``` и пробелы, однако более удобны для использования. Пример:
```shell
# Напечатает "Hello, my lovely CMake", один таб и "!":
message("Hello, my lovely CMake\t!")

# Напечатает "Hello,_my_lovely_CMake!" без пробелов:
message(Hello,_my_lovely_CMake!)
```

**Комментарии**  
Комментарии начинаются с символа решётки и заканчиваются в конце той строки, где они были напечатаны (см. примеры выше).

**Переменные**  
Переменные можно определить путём вызова команды ```set```, а удалить вызовом ```unset```. Получить значение переменной можно по конструкции ```${VARIABLE}```. Если переменная ещё не определена и где-то потребовалось получить её значение, то данная переменная обратится в пустую строку. Пример:
```shell
# Определить переменную VARIABLE со значением "Mr. Thomas":
set(VARIABLE "Mr. Thomas")

# Напечает "His name is: Mr. Thomas":
message("His name is: " ${VARIABLE})

# Напечатает "'BINGO' is equal to: []", так как "BINGO" не определена:
message("'BINGO' is equal to: [${BINGO}]")

# Удалить переменную VARIABLE:
unset(VARIABLE)
```

**Опции**  
CMake поддерживает задание опций, подлежащих модицификациям пользователей. Опции похожи на переменные и задаются командой ```option```, принимающей всего три аргумента: имя переменной, строковое описание переменной и значение переменной по умолчанию (```ON``` или ```OFF```):
```shell
# Задать опцию `USE_ANOTHER_LIBRARY` с описанием
# "Do you want to use an another library?" и значением "OFF":
option(USE_ANOTHER_LIBRARY "Do you want to use an another library?" OFF)
```

**Условные операторы**
```shell
# Напечатает "Of course, 5 > 1!":
if(5 GREATER 1)
    message("Of course, 5 > 1!")
elseif(5 LESS 1)
    message("Oh no, 5 < 1!")
else()
    message("Oh my god, 5 == 1!")
endif() 
```

**Циклы**
```shell
# Напечатает в консоль три раза "VARIABLE is still 'Airport'":
set(VARIABLE Airport)
while(${VARIABLE} STREQUAL Airport)
    message("VARIABLE is still '${VARIABLE}'")
    message("VARIABLE is still '${VARIABLE}'")
    message("VARIABLE is still '${VARIABLE}'")
    set(VARIABLE "Police station")
endwhile()
```

```shell
# Напечатает "Give me the sugar please!" с новых строк:
foreach(VARIABLE Give me the sugar please!)
    message(${VARIABLE})
endforeach()
```

```shell
# Напечатает "0 1 2 3 4 5 6 7 8 9 10" с новых строк:
foreach(VARIABLE RANGE 10)
    message(${VARIABLE})
endforeach()

# Напечатает "3 4 5 6 7 8 9 10 11 12 13 14 15" с новых строк:
foreach(VARIABLE RANGE 3 15)
    message(${VARIABLE})
endforeach()

# Напечатает "50 60 70 80 90" с новых строк:
foreach(VARIABLE RANGE 50 90 10)
    message(${VARIABLE})
endforeach()
```

***Еще есть функции и макросы, о них вы можете сами почитать в сети.***  

Система сборки CMake принимает на вход файл ```CMakeLists.txt``` с описанием правил сборки на формальном языке CMake, а затем генерирует промежуточные и нативные файлы сборки в том же каталоге, принятых на Вашей платформе.  

Сгенерированные файлы будут содержать конкретные названия системных утилит, директорий и компиляторов, в то время как команды CMake орудуют лишь абстрактным понятием компилятора и не привязаны к платформенно зависимым инструментам, сильно различающихся на разных операционных системах.

**Проверка версии CMake**  
```shell
# Задать третью минимальную версию CMake:
cmake_minimum_required(VERSION 3.0)
```
Некоторые разработчики намеренно выставляют низкую версию CMake, а затем корректируют функционал вручную. Это позволяет одновременно поддерживать древние версии CMake и местами использовать новые возможности.

**Оформление проекта**  
В начале любого ```CMakeLists.txt``` следует задать характеристики проекта командой project для лучшего оформления интегрированными средами и прочими инструментами разработки.
```shell
# Задать характеристики проекта "MyProject":
project(MyProject VERSION 1.2.3.4 LANGUAGES C CXX)
```
Стоит отметить, что если ключевое слово ```LANGUAGES``` опущено, то по умолчанию задаются языки ```C``` ```CXX```. Вы также можете отключить указание любых языков путём написания ключевого слова ```NONE``` в качестве списка языков или просто оставить пустой список.

**Сборка исполняемых файлов**
Команда ```add_executable``` собирает исполняемый файл с заданным именем из списка исходников. Важно отметить, что окончательное имя файла зависит от целевой платформы (например, ```<ExecutableName>.exe``` или просто ```<ExecutableName>```). Типичный пример вызова данной команды:
```shell
# Собрать исполняемый файл "MyExecutable" из
# исходников "ObjectHandler.c", "TimeManager.c" и "MessageGenerator.c":
add_executable(MyExecutable ObjectHandler.c TimeManager.c MessageGenerator.c)
```

**Сборка библиотек из файлов**  
Команда ```add_library``` собирает библиотеку с указанным видом и именем из исходников. Важно отметить, что окончательное имя библиотеки зависит от целевой платформы (например, ```LibraryName>.a``` или ```<LibraryName>.lib```). Типичный пример вызова данной команды:
```shell
# Собрать статическую библиотеку "MyLibrary" из
# исходников "ObjectHandler.c", "TimeManager.c" и "MessageConsumer.c":
add_library(MyLibrary STATIC ObjectHandler.c TimeManager.c MessageConsumer.c)
```
Также вторым аргументом можно задать ```SHARED```/```MODULE```/```OBJECT``` в зависимости от типа библиотеки.

**Добавление исходников к цели**  
Бывают случаи, требующие многократного добавления исходных файлов к цели. Для этого предусмотрена команда ```target_sources```, способная добавлять исходники к цели множество раз.  
Первым аргументом команда ```target_sources``` принимает название цели, ранее указанной с помощью команд ```add_library``` или ```add_executable```, а последующие аргументы являются списком добавляемых исходных файлов.  
Повторяющиеся вызовы команды ```target_sources``` добавляют исходные файлы к цели в том порядке, в каком они были вызваны, поэтому нижние два блока кода являются функционально эквивалентными:
```shell
# Задать исполняемый файл "MyExecutable" из исходников
# "ObjectPrinter.c" и "SystemEvaluator.c":
add_executable(MyExecutable ObjectPrinter.c SystemEvaluator.c)

# Добавить к цели "MyExecutable" исходник "MessageConsumer.c":
target_sources(MyExecutable MessageConsumer.c)
# Добавить к цели "MyExecutable" исходник "ResultHandler.c":
target_sources(MyExecutable ResultHandler.c)
```
```shell
# Задать исполняемый файл "MyExecutable" из исходников
# "ObjectPrinter.c", "SystemEvaluator.c", "MessageConsumer.c" и "ResultHandler.c":
add_executable(MyExecutable ObjectPrinter.c SystemEvaluator.c MessageConsumer.c ResultHandler.c)
```

**Компоновка с библиотеками**  
Команда ```target_link_libraries``` компонует библиотеку или исполняемый файл с другими предоставляемыми библиотеками. Первым аргументом данная команда принимает название цели, сгенерированной с помощью команд ```add_executable``` или ```add_library```, а последующие аргументы представляют собой названия целей библиотек или полные пути к библиотекам. Пример:
```shell
# Скомпоновать исполняемый файл "MyExecutable" с
# библиотеками "JsonParser", "SocketFactory" и "BrowserInvoker":
target_link_libraries(MyExecutable JsonParser SocketFactory BrowserInvoker)
```

**Добавление подпроектов**  
Команда ```add_subdirectory``` побуждает CMake к незамедлительной обработке указанного файла подпроекта. Пример ниже демонстрирует применение описанного механизма:
```shell
# Добавить каталог "subLibrary" в сборку основного проекта,
# а генерируемые файлы расположить в каталоге "subLibrary/build":
add_subdirectory(subLibrary subLibrary/build)
```

