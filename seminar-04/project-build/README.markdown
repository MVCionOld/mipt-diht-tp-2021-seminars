# Системы сборки

### Agenda
  * Стадии сборки проекта
  * Инструментарий для сборки
    * сборочные bash-скрипты
    * make
    * cmake
    
# Cтадии сборки проекта

Насколько верно со снобисткой точки зрения фразочки в духе: "программа откомпилировалась без ошибок" или "скомпилируй программу, посмотрим на результат работы"?  
Подсказка: ничего хорошо, они приводят только к путаницы начинающих программистов и говорят об отсутствии компетенции у автора подобных фразочек.
<details><summary>А что тогда говорить?</summary>
<p>
Исходник на C++ — это всего лишь plain text, это значит, что сам по себе он бесполезен, на него можно только глазками посмотреть. 
Поэтому каждый исходный файл требуется скомпилировать в исполняемый файл, динамическую или статическую библиотеки (пытливый читатель
спросит в чем разница между динамической и статической библиотекой — гугл в помощь млм дождитесь АКОСа).  
  
Итак, сами стадии сборки проекта:
  1. Препроцессинг
  2. Компиляция
  3. Ассемблирование
  4. Компоновка (линковка)

**Препроцессинг**  
На данной стадии происходит происходит работа с препроцессорными директивами. Например, препроцессор добавляет хэдеры в код (#include), убирает комментирования, заменяет макросы (#define) их значениями, выбирает нужные куски кода в соответствии с условиями #if, #ifdef и #ifndef.  
```bash
g++ -E -o main.i main.cpp
```

**Компиляция**  
На данной стадии происходит преобразование полученном на прошлом шаге кода без директив в ассемблерный код.
_Ассемблерный код_ — это доступное для понимания человеком представление машинного кода.
```bash
g++ -S -o main.s main.cpp
```

**Ассемблирование**  
На данной стадии необходимо перевести ассемблерный код в машинный с помощью ассемблера.
Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном файле. 
_Объектный файл_ — это созданный ассемблером промежуточный файл, хранящий кусок машинного кода. Этот кусок машинного кода, который еще не был связан вместе с другими кусками машинного кода в конечную выполняемую программу, называется объектным кодом.
```bash
g++ -c -o main.o main.cpp
```
или
```bash
as main.s -o main.o
```
**Компоновка**  
На данной стадии происходит связывание всех объектных файлов и статических библиотек в единый исполняемый файл, который мы и сможем запустить в дальнейшем.
```bash
g++ main.o file1.o ... fileN.o lib1.o ... libN.o -o main
```

**\*Загрузка**  
Формально к сборке проекта никакого отношения не имеет, но надо понимать, что для непосредственно
запуска нашего приложения, программу надо загрузить в память. 

</p>
</details>

### Обсудив стадии сборки проекта, заодно мы сразу посмотрели на сборочные bash-скрипты, какие недостатки такого подхода вы сразу можете назвать?

### Make
make — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта. Сам скрипт состоит из набора правил, которые в свою очередь описываются:

1) целями (то, что данное правило делает);
2) реквизитами (то, что необходимо для выполнения правила и получения целей);
3) командами (выполняющими данные преобразования).

В общем виде синтаксис makefile можно представить так:  
```bash
# Индентация осуществляется исключительно при помощи символов табуляции,
# каждой команде должен предшествовать отступ
<цели>: <реквизиты>
	<команда 1>
	...
	<команда N>
```
Несложно заметить что процессы трансляции и компиляции очень красиво ложатся на эту схему:
```bash
{исходные файлы} ---> [трансляция] ---> {объектные файлы}
```
```bash
{объектные файлы} ---> [линковка] ---> {исполнимые файлы}
```

**Простейший пример использования make**
```c
/*
 * main.c
 */
#include <stdio.h>
int main() {
	printf("Hello World!\n");
	return 0;
}
```
```bash
hello: main.c
	gcc -o hello main.c
```
Теперь для сборки достаточно вызвать нужное правило:
```bash
$ make hello
```
Заодно посмотрим на многофайловый пример.  
...  
А что если наша программа состоит из десятка-другого исходных файлов. Мы вносим изменения в один из них, и хотим ее пересобрать. 
Использование подхода описанного в предыдущем примере приведет к тому, что все без исключения исходные файлы будут снова скомпилированы, что негативно скажется на времени перекомпиляции. Решение — разделить компиляцию на два этапа: этап трансляции в объектные файлы и этап линковки.  
```bash
main.o: main.c
        gcc -c -o main.o main.c
hello.o: hello.c
        gcc -c -o hello.o hello.c
hello: main.o hello.o
        gcc -o hello main.o hello.o
```
**Фиктивные цели**  
На самом деле, в качестве make целей могут выступать не только реальные файлы. Проделывать такие фокусы нам позволяют так называемые фиктивные (phony) цели. Вот краткий список стандартных целей:
  * ```all``` — является стандартной целью по умолчанию, при вызове make ее можно явно не указывать
  * ```clean``` — очистить каталог от всех файлов полученных в результате компиляции
  * ```install``` — произвести инсталляцию
  * ```uninstall``` — и деинсталляцию соответственно
Пример Makefile с целями all, clean, install и uninstall:
```bash
.PHONY: all clean install uninstall
	
all: hello
	
clean:
			rm -rf hello *.o
main.o: main.c
			gcc -c -o main.o main.c
hello.o: hello.c
			gcc -c -o hello.o hello.c
hello: main.o hello.o
			gcc -o hello main.o hello.o
install:
			install ./hello /usr/local/bin
uninstall:
			rm -rf /usr/local/bin/hello
```
Также в Makefile можно использовать переменные по bash'овому подходу:
```bash
<VAR_NAME> = <value string>
```
чтобы получить значение по переменной воспользуемся следующим синтаксисом:
```bash
SRC = main.c hello.c
gcc -o hello $(SRC)
```
**перед знаком доллара не должно быть слэша**
```bash
TARGET = hello
PREFIX = /usr/local/bin

.PHONY: all clean install uninstall

all: $(TARGET)
	
clean:
			rm -rf $(TARGET) *.o
main.o: main.c
			gcc -c -o main.o main.c
hello.o: hello.c
			gcc -c -o hello.o hello.c
$(TARGET): main.o hello.o
			gcc -o $(TARGET) main.o hello.o
install:
			install $(TARGET) $(PREFIX)
uninstall:
			rm -rf $(PREFIX)/$(TARGET)
```
### CMake



