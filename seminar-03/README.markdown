# Что такое паттерн проектирования?

**Паттерн проектирования** — это часто встречающееся решение определённой проблемы (шаблонизированный подход к решению проблемы) при проектировании архитектуры программ.

Самые низкоуровневые и простые паттерны — *идиомы*. Они не универсальны, поскольку применимы только в рамках одного языка программирования. Например, в С++ применение идиомы RAII:
```c++
std::string GetFirstLineOf(const char* filename) {
    // Stack allocated
    OpenFile file(filename);
    return file.ReadLine();
    // File closed here, it goes out of scope and destructor is run.
}
```
или list/dict/set/generator comprehensions в Python:
```python
>>> [2**x for x in range(10)]
    # [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
>>> {x%2 for x in range(10)}
    # {0, 1}
>>> {x: x>4 for x in range(10)}
    # {0: False, ..., 4: False, 5: True, ..., 10: True}
>>> (2**x for x in range(10))
    # <generator object <genexpr> at 0x7fe8f7e6f740>
```

Самые универсальные — архитектурные паттерны, которые можно реализовать практически на любом языке. Они нужны для проектирования всей программы, а не отдельных её элементов.
Кроме того, паттерны отличаются и предназначением. Есть три основные группы паттернов:
  * **Порождающие**: беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей, Ctrl+C & Ctrl+V Driven Development и прочих "радостей" разработки.
  * **Структурные**: показывают различные способы построения связей между объектами.
  * **Поведенческие**: заботятся об эффективной коммуникации между объектами и их поведении (извините за тавтологию).

Важно понимать, что паттерны это не готовые функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы.
Также не стоит путать паттерны с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может отличаться почти наверное.
Житейская аналогия: алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на котором нарисовано решение, но не конкретные шаги его реализации.


Описания паттернов обычно очень формальны и чаще всего состоят из таких пунктов:
  * имя паттерна
  * задача, которую должен решить паттерн
  * решение, которое предполагает подход (читай дословно "паттерн")
  * результат применения данного подхода (например, количество классов в иерархии наследования станет не N * M, а N + M)

---

# UML нотация (диаграммы классов)

**UML** (**U**nified **M**odelling **L**anguage, рус. "унифицированный язык моделирования") - стандарт при описании объектно-ориентированных систем.

![Пример](images/uml-example.png)
![База](images/class-notation.png)
![Композиция](images/composition.png)
![Агрегация](images/aggregation.png)
![Интерфейсы](images/interfaces.png)
![Наследование
](images/inheritance.png)

---

# Singleton (Одиночка)
  * Имя - Singleton
  * Задача - создать класс с единственным экземпляр
  * Решение - ???
  * Результат - у класса есть только один экземпляр, предоставляем к нему глобальную точку доступа
<details><summary>Решение</summary>
<p>

```c++
// Singleton.h
class Singleton {
private:
  static Singleton* p_instance;
  // Конструкторы и оператор присваивания недоступны клиентам
  Singleton () {}
  Singleton (const Singleton&);
  Singleton& operator= (Singleton&);
public:
  static Singleton* GetInstance() {
    if (p_instance != nullptr) {
      p_instance = new Singleton();
    }
    return p_instance;
  }
};

// Singleton.cpp
#include "Singleton.h"

Singleton* Singleton::p_instance = nullptr;
```

Приведенная выше реализация подразумевает, что клиенты должны сами позаботиться об освобождении памяти при помощи оператора `delete`.
Последняя особенность является серьезным недостатком классической реализации шаблона `Singleton`. Так как класс сам контролирует создание единственного объекта, было бы логичным возложить на него ответственность и за разрушение объекта. Этот недостаток отсутствует в реализации `Singleton`, впервые предложенной Скоттом Мэйерсом.

```c++
// Singleton.h
class Singleton {
private:
  Singleton () {}
  Singleton (const Singleton&);
  Singleton& operator= (Singleton&);
public:
  static Singleton& GetInstance() {
    static Singleton instance;
    return instance;
  }src
}; 
```

Тоже самое на `Python`:

```python
class Singleton(object):

    def __new__(cls):
        # Перекрываем создание объекта класса
        if not hasattr(cls, 'instance'):
            cls.instance = super(Singleton, cls).__new__(cls)
        return cls.instance
```

</p>
</details>

# Prototype (Прототип)
  * Имя - Prototype
  * Задача - скопировать объект класса (в том числе в глубокой иерархии классов), почему просто нельзя вызвать конструктор?
  * Решение - ???
  * Результат - копирующий код независим от классов копируемых объектов
<details><summary>Решение</summary>
<p>
Поручим создание копий самим копируемым объектам. Вводем общий интерфейс для всех объектов, поддерживающих клонирование. Это позволяет копировать объекты, не привязываясь к их конкретным классам. Обычно такой интерфейс имеет всего один метод clone.  <br/>
Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта. Так получится скопировать даже приватные поля, так как большинство языков программирования разрешает доступ к приватным полям любого объекта текущего класса.  <br/>
Объект, который копируют, называется прототипом (откуда и название паттерна). Когда объекты программы содержат сотни полей и тысячи возможных конфигураций, прототипы могут служить своеобразной альтернативой созданию подклассов. <br/>
<a href="images/prototype.png"> Схема </a>
</p>
</details>
